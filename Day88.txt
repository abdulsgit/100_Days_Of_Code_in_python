def findpivotwithduplicates(arr):
    start = 0
    end = len(arr)-1

    while start<=end:
        mid = start+(end-start)//2
        #we are going to have 4 scenarios in this search
        #case1:
        #if mid is last index of the array in a scenario it will give index out of bound range due to mid+1 so to avoid it
        #we will add mid<end
        if mid<end and arr[mid]>arr[mid+1]:
            return mid
        #case 2:
        if arr[mid]<arr[mid-1]:
            return mid-1

        #if elements at start,middle,end are equal just skip the duplicates
        if arr[mid]==arr[start] and arr[mid]==arr[end]:

            #note: what if these elements at start and end were the pivot
            #check if start is pivot
            if arr[start]>arr[start+1]:
                return start
            #skips the duplicate
            start+=1

            #check whether end is pivot
            if arr[end]<arr[end-1]:
                return end-1
            #skips the duplicate end
            end-=1

        #left side is sorted so pivot should be in right
        elif arr[start]<arr[mid] or arr[start]==arr[mid] and arr[mid]>arr[end]:
            start = mid+1
        else:
            end=mid-1
    return -1

arr=[2,9,2,2,2]
print(findpivotwithduplicates(arr))


2)Rotated Binary search with Duplicate Values


def search(nums, target):
    pivot = findpivotwithduplicates(nums)
    # if we dont have a pivot it means array is not rotated
    if pivot == -1:
        # just do normal binary search
        return binarysearch(arr, target, start=0, end=len(arr) - 1)

    # if pivot is found we have found 2 ascending sorted arrays
    if nums[pivot] == target:
        return pivot

    if target >= nums[0]:
        return binarysearch(arr, target, start=0, end=pivot - 1)

    return binarysearch(arr, target, start=pivot + 1, end=len(arr) - 1)


def findpivotwithduplicates(arr):
    start = 0
    end = len(arr)-1

    while start<=end:
        mid = start+(end-start)//2
        #we are going to have 4 scenarios in this search
        #case1:
        #if mid is last index of the array in a scenario it will give index out of bound range due to mid+1 so to avoid it
        #we will add mid<end
        if mid<end and arr[mid]>arr[mid+1]:
            return mid
        #case 2:
        if arr[mid]<arr[mid-1]:
            return mid-1

        #if elements at start,middle,end are equal just skip the duplicates
        if arr[mid]==arr[start] and arr[mid]==arr[end]:

            #note: what if these elements at start and end were the pivot
            #check if start is pivot
            if arr[start]>arr[start+1]:
                return start
            #skips the duplicate
            start+=1

            #check whether end is pivot
            if arr[end]<arr[end-1]:
                return end-1
            #skips the duplicate end
            end-=1

        #left side is sorted so pivot should be in right
        elif arr[start]<arr[mid] or arr[start]==arr[mid] and arr[mid]>arr[end]:
            start = mid+1
        else:
            end=mid-1
    return -1

def binarysearch(arr,target,start,end):


    while start<=end:
        #find the middle element
        #mid = start+end//2 #might be possible that after adding it may exceeds the range may give error
        #we can do instead of above line is mid = end-start//2
        #or we can do this below line instead
        mid =start +(end-start)//2

        if target<arr[mid]:
            end = mid-1
        elif target>arr[mid]:
            start = mid + 1
        else:
            #target==arrr[mid]
            return mid
    #nothing returns in while loop then it will return
    return -1

arr = [2,9,2,2,2]
target=9
print(search(arr,target))


3)Rotation Count In an array

#for non duplicate
def pivot(arr):
    start = 0
    end = len(arr)-1

    while start<=end:
        mid = start+(end-start)//2
        #we are going to have 4 scenarios in this search
        #case1:
        #if mid is last index of the array in a scenario it will give index out of bound range due to mid+1 so to avoid it
        #we will add mid<end
        if mid<end and arr[mid]>arr[mid+1]:
            return mid

        #case 2:
        if arr[mid]<arr[mid-1]:
            return mid-1

        #case 3
        if arr[mid]<arr[start]:
            end = mid-1
        else:
            start=mid+1
    return -1

#for duplicate
def findpivotwithduplicates(arr):
    start = 0
    end = len(arr)-1

    while start<=end:
        mid = start+(end-start)//2
        #we are going to have 4 scenarios in this search
        #case1:
        #if mid is last index of the array in a scenario it will give index out of bound range due to mid+1 so to avoid it
        #we will add mid<end
        if mid<end and arr[mid]>arr[mid+1]:
            return mid
        #case 2:
        if arr[mid]<arr[mid-1]:
            return mid-1

        #if elements at start,middle,end are equal just skip the duplicates
        if arr[mid]==arr[start] and arr[mid]==arr[end]:

            #note: what if these elements at start and end were the pivot
            #check if start is pivot
            if arr[start]>arr[start+1]:
                return start
            #skips the duplicate
            start+=1

            #check whether end is pivot
            if arr[end]<arr[end-1]:
                return end-1
            #skips the duplicate end
            end-=1

        #left side is sorted so pivot should be in right
        elif arr[start]<arr[mid] or arr[start]==arr[mid] and arr[mid]>arr[end]:
            start = mid+1
        else:
            end=mid-1
    return -1

def rotationcount(arr):
    Pivot = pivot(arr)
    if Pivot == -1: #array is not rotated
        return 0
    else:
        return Pivot+1




arr = [4,5,6,7,0,1,2]
print(rotationcount(arr))
